포인터
------

- 포인터란? 특정한 데이터의 **주소값**을 보관하는 변수

&연산자
------
- 우리가 데이터의 주소값을 아는 방법?
  - &연산자를 통해
- & 연산자를 사용하면 특정한 데이터의 메모리상 주소값을 알 수 있음

*표
----
- 포인터를 정의할 때 사용하였던 *과는 다름
  - *연산자 : 나에 저장된 주소값에 해당하는 데이터
  

배열의 이름
-------
- 배열의 이름은 배열의 시작 주소값을 지칭함
  - = 배열의 이름은 배열의 시작 주소를 가리키는 포인터
  
[] 연산자
-------
- [] 연산자가 쓰이면 자동으로 포인터 형태로 바꿈
  - arr[3]은 *(arr + 3)과 같음
  
1차원 배열 가리키기
-------------
```
#include <stdio.h>
int main() {
  int arr[3] = {1, 2, 3};
  int *parr;

  parr = arr;
  /* parr = &arr[0]; 도 동일하다! */

  printf("arr[1] : %d \n", arr[1]);
  printf("parr[1] : %d \n", parr[1]);
  return 0;
}
```
- int형 1차원 배열을 가리키는 int* 포인터 parr
  - parr은 배열 arr을 가리킴
- 굳이 parr을 따로 선언하는 이유?
  - 배열 이름은 const라 arr의 값을 바꿀 수 없기 때문에
  
2차원 배열의 [] 연산자
-------------
- arr[0]에 저장된 값이 arr[0][0]에 저장된 값과 같고, arr[1]에 저장된 값이 arr[1][0]의 주소값과 같음
  - arr[0]은 arr[0][0]을 가리키는 포인터이고, arr[1]은 arr[1][0]을 가리키는 포인터
  - arr[0]이 int* 형이므로 arr[0][0]을 가리키는 arr은 int**형일까?
    - **아님**
    
포인터의 형(Type)을 결정짓는 두 가지 요소
---------------
- 1차원 배열에서 n번째 원소의 주소값을 알아내는 법(배열의 형 int, 시작 주소 x)
  - x + 4(n - 1)
- 2차원 배열 int arr[a][b]에서 arr[c][d]의 주소값을 알아내는 법 (배열의 형 int, 시작 주소 x)
  - x + 4bc + 4d
  - 주소값을 위해서는 b가 필요함. 그러므로 int**로 배열의 이름을 나타낼 수 없는 것.
  
- 포인터의 형을 결정하는 두 가지 요소
  1. 가리키는 것에 대한 정보 (int* 형이면 int를 가리킨다, char**이면 char*을 가리킨다)
  2. 1 증가시 커지는 크기 (2차원 배열에서는 b*(형의 크기)를 의미한다)
  
2차원 배열을 가리키는 포인터
------------------
```
#include <stdio.h>
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int(*parr)[3];  // 괄호를 꼭 붙이세요

  parr = arr;  // parr 이 arr 을 가리키게 한다.

  printf("parr[1][2] : %d , arr[1][2] : %d \n", parr[1][2], arr[1][2]);

  return 0;
}
```
<출력결과>
- parr[1][2] : 6 , arr[1][2] : 6
  
- 2차원 배열을 가리키는 포인터는 아래와 같은 형식으로 씀
  - (배열의 형) ( *(포인터 이름) )[2차원 배열의 열 개수] ;
  
포인터 배열
---------
```
#include <stdio.h>
int main() {
  int *arr[3];
  int a = 1, b = 2, c = 3;
  arr[0] = &a;
  arr[1] = &b;
  arr[2] = &c;

  printf("a : %d, *arr[0] : %d \n", a, *arr[0]);
  printf("b : %d, *arr[1] : %d \n", b, *arr[1]);
  printf("b : %d, *arr[2] : %d \n", c, *arr[2]);

  printf("&a : %d, arr[0] : %d \n", &a, arr[0]);
  return 0;
}
```
<출력결과>  
a : 1, *arr[0] : 1  
b : 2, *arr[1] : 2  
b : 1, *arr[2] : 3  
&a : 2555184, arr[0] : 255184  
