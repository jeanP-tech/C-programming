포인터란?
-------------

- 포인터는 '주소'를 가리킴
- 포인터 변수라고 부르기도 함
- 변수면 어떤 값을 저장하는 것. 포인터는 '주소값'을 저장함.
- 변수를 선언할 때는 담고자 하는 자료형에 *(참조 연산자)를 붙여서 선언
  - 포인터 변수의 크기는 모두 동일. 32비트 시스템이면 4바이트, 64비트 시스템이면 8바이트.
  - 그런데 자료형에 따라 선언하는 자료형이 달라지는 이유는, 가리킬 주소가 어떤 자료형을 갖는지 알려주기 위해서.
- 포인터는 주소값을 담는 변수이기 때문에 어떤 특정한 숫자를 넣을 수 없음
  - 숫자가 아닌 NULL(0)만 가능
  - NULL로 초기화하지 않으면 쓰레기값을 갖게 됨
- 주소값을 담을 때는 &을 붙여준다
  - 선언할 때는 *p로 해주었지만, 주소값을 넣을 때는 p = &num 형태로 *연산자를 떼준다
  
참조 연산자 *
-----
- *p는 그 주소로 찾아가서 들어있는 값을 반환하는 것이므로 증가된 num의 값 출력.
- 그런데 (*p)++과 *p++의 값이 다름
  - 증감연산자(++, --)가 참조연산자(*)보다 우선순위가 높다
  - *p++의 경우 주소를 먼저 찾아가지 않고 주소값이 들어있는 변수 p를 먼저 증가시킴
  - 증가한 그 주소에는 아무것도 선언되어 있지 않으므로 쓰레기값을 가르키게 됨
  
왜 포인터를 이용할까?
- 포인터는 함수를 사용할 때 진가를 발휘함
- 함수에서는 인자를 전달할 때 복사 이용
  - 즉, 전달해주는 원래 변수는 함수에서 수정할 수 없다
- 포인터는 메모리의 주소를 넘겨주면 함수에서도 메모리에 직접적으로 참조할 수 있기에, 변수의 값 수정 가능

Call by value & Call by reference
----

1. Call by value

- 기본적으로 C언어에서 지원하는 방식
- 함수에서 값을 복사해서 전달하는 방식. 인자로 전달되는 변수를 함수의 매개변수에 복사함.
- 복사되면 인자로 전달한 변수와는 별개의 변수가 되며, 매개변수를 변경해도 원래의 변수에는 영향을 미치지 않음.
  
2. Call by reference

- 함수에서 값을 전달하는 대신 주소값을 전달하는 방식
- C언어에서의 방식은 주소값 자체를 복사해서 넘겨주는 것이므로 call by value
  - 이렇게 주소값을 복사해서 넘겨주는 것을 call by address 방식이라고 함
  - C언어에서는 call by reference를 공식적으로 지원하지 않음
  - 그러나 결과적으로 call by reference와 같이 사용할 수 있기 때문에 call by reference라고 설명하기도 함
    
요약: C언어에서 함수 인자 전달은 원칙적으로 모두 Call by value이지만, 포인터를 사용하여 Call by reference를 구현할 수 있다

포인터로 버블 정렬 함수 만들기
---------

```
#include <stdio.h>

void BubbleSort(int *parr);

int main() {
	int arr[10];
	for(int i = 0; i < 10; i++){
		scanf("%d ", &arr[i]); 
	}
	
	BubbleSort(&arr);
	
	for(int i=0; i<10; i++){
		printf("%d ", arr[i]);
	}
	
	return 0;
}

void BubbleSort(int *parr){
	int i, j;
	int temp;
	
	for(i = 0; i < 9; i++){
		for(j = 0; j < 9; j++){
			if(parr[j] > parr[j + 1]){
				temp = parr[j];
				parr[j] = parr[j + 1];
				parr[j + 1] = temp;
			}			
		}
	}
}
```

포인터 연산과 배열
---------
배열의 이름은 포인터 변수와 같은 기능을 하며, 첫번째 요소의 주소값을 나타낸다.  
scanf로 입력받을 때 문자열은 &연산자를 붙여주지 않아도 되는 이유.  
  
포인터 연산
- 포인터 변수도 일반 변수처럼 증감 연산을 할 수 있다.
- ++, --와 같은 전/후위 연산과 +, - 연산자 같은 일반 덧셈과 뺄셈 가능. 곱셈, 나눗셈 불가능.
- int형 포인터는 4씩, double형 포인터는 8식 증가
  - 포인터 변수가 n만큼 더하거나 뺄 때 자료형의 크기 x n 만큼 증가, 감소
- 포인터를 배열처럼 사용할 수 있는 방법 *(arr+i) == arr[i]
  - 포인터의 이름은 배열의 첫번째 원소의 주소를 가리키므로, i x 자료형의 크기만큼 더해지면 배열 i와 같은 것
  
상수 포인터
---------

- 포인터가 가리키는 변수를 상수화
  - const int * ptr과 같이 const를 가장 앞에 사용하면, 이 포인터를 이용해 변수의 값을 변경하는 것을 막음

```
#include <stdio.h?

int main(){
  int num = 10;
  int *ptr1 = &num;
  const int *ptr2 = &num;
  
  *ptr1 = 20;
  num = 30;
  
  *ptr2 = 40;
  
  return 0;
}
```
위 코드에서 const로 선언하지 않은 ptr1은 * ptr1을 이용해 값 20을 대입할 수 있음.  
하지만 ptr2는 상수화되었기에 변수의 값을 변경할 수 없음.  
그렇다고 변수 num 자체가 상수화된 것은 아니라 num의 값을 변경하는 것은 가능.

- 포인터 상수화
  - int* const ptr과 같이 자료형 다음에 const를 선언하면 포인터 변수 자체가 상수화 됨. 주소값을 변경할 수 없음.
  - 포인터를 상수화시킬 때는 const 전에 * 연산자를 써주어야 함.
  
포인터를 통해 값을 변경하는 것도, 다른 변수를 가리키는 것도 불가능하게 하고 싶다면 const를 두 번 써주는 것도 가능.

이중 포인터
------------
이중 포인터는 포인터의 주소값을 담는 변수. 포인터의 포인터.
```
#include <stdio.h>

int main(){
  int num = 10;
  int *ptr;
  int **pptr;
  
  ptr = &num;
  pptr = &ptr;
  
  printf("num : %d *ptr : %d **ptr : %d, num, *ptr, **pptr);
  printf("num 주소 : %d *ptr 값 : %d **ptr 값 : %d\n", &num, ptr, *pptr);
  printf("ptr 주소 : %d pptr 값 : %d", &ptr, pptr);
  
  return 0;
}
```
이중 포인터는 그 포인터가 가리키고 있는 곳으로 가서, 그 포인터가 가리키는 주소로 찾아가서 그 변수의 값을 사용.  
So, 첫번째 출력문의 num 값과 * ptr, ** ptr 값이 모두 같음.  
이중포인터는 참조 포인터를 하나만 쓸 수도 있음. 이럴 경우 pptr이 가리키고 있는 값을 의미.  
= ptr 변수에 들어있는 값 = num의 주소값  
(마지막 출력문) pptr은 ptr을 가리키고 있는 포인터. 변수에는 ptr의 주소값이 들어있음.  

포인터 배열
----------

일반 배열과 똑같은데, 포인터가 들어감.  
```
#include <stdio.h>

int main(){
  int num1 = 10, num2 = 20, num3 = 30;
  int *parr[3];
  
  parr[0] = &num1;
  parr[1] = &num2;
  parr[2] = &num3;
  
  for(int i=0; i<3; i++){
    printf("parr[%d] : %d\n", i, *parr[i]);
  }
  
  return 0;
}
```
  
