포인터란?
-------------

- 포인터는 '주소'를 가리킴
- 포인터 변수라고 부르기도 함
- 변수면 어떤 값을 저장하는 것. 포인터는 '주소값'을 저장함.
- 변수를 선언할 때는 담고자 하는 자료형에 *(참조 연산자)를 붙여서 선언
  - 포인터 변수의 크기는 모두 동일. 32비트 시스템이면 4바이트, 64비트 시스템이면 8바이트.
  - 그런데 자료형에 따라 선언하는 자료형이 달라지는 이유는, 가리킬 주소가 어떤 자료형을 갖는지 알려주기 위해서.
- 포인터는 주소값을 담는 변수이기 때문에 어떤 특정한 숫자를 넣을 수 없음
  - 숫자가 아닌 NULL(0)만 가능
  - NULL로 초기화하지 않으면 쓰레기값을 갖게 됨
- 주소값을 담을 때는 &을 붙여준다
  - 선언할 때는 *p로 해주었지만, 주소값을 넣을 때는 p = &num 형태로 *연산자를 떼준다
  
참조 연산자 *
-----
- *p는 그 주소로 찾아가서 들어있는 값을 반환하는 것이므로 증가된 num의 값 출력.
- 그런데 (*p)++과 *p++의 값이 다름
  - 증감연산자(++, --)가 참조연산자(*)보다 우선순위가 높다
  - *p++의 경우 주소를 먼저 찾아가지 않고 주소값이 들어있는 변수 p를 먼저 증가시킴
  - 증가한 그 주소에는 아무것도 선언되어 있지 않으므로 쓰레기값을 가르키게 됨
  
왜 포인터를 이용할까?
- 포인터는 함수를 사용할 때 진가를 발휘함
- 함수에서는 인자를 전달할 때 복사 이용
  - 즉, 전달해주는 원래 변수는 함수에서 수정할 수 없다
- 포인터는 메모리의 주소를 넘겨주면 함수에서도 메모리에 직접적으로 참조할 수 있기에, 변수의 값 수정 가능

Call by value & Call by reference
----

1. Call by value

- 기본적으로 C언어에서 지원하는 방식
- 함수에서 값을 복사해서 전달하는 방식. 인자로 전달되는 변수를 함수의 매개변수에 복사함.
- 복사되면 인자로 전달한 변수와는 별개의 변수가 되며, 매개변수를 변경해도 원래의 변수에는 영향을 미치지 않음.
  
2. Call by reference

- 함수에서 값을 전달하는 대신 주소값을 전달하는 방식
- C언어에서의 방식은 주소값 자체를 복사해서 넘겨주는 것이므로 call by value
  - 이렇게 주소값을 복사해서 넘겨주는 것을 call by address 방식이라고 함
  - C언어에서는 call by reference를 공식적으로 지원하지 않음
  - 그러나 결과적으로 call by reference와 같이 사용할 수 있기 때문에 call by reference라고 설명하기도 함
    
요약: C언어에서 함수 인자 전달은 원칙적으로 모두 Call by value이지만, 포인터를 사용하여 Call by reference를 구현할 수 있다

포인터로 버블 정렬 함수 만들기
---------

